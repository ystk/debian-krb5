--- krb5-1.12.1+dfsg.orig/src/lib/krb5/asn.1/asn1_encode.c
+++ krb5-1.12.1+dfsg/src/lib/krb5/asn.1/asn1_encode.c
@@ -393,7 +393,7 @@ make_tag(asn1buf *buf, const taginfo *t,
 static asn1_error_code
 get_tag(const unsigned char *asn1, size_t len, taginfo *tag_out,
         const unsigned char **contents_out, size_t *clen_out,
-        const unsigned char **remainder_out, size_t *rlen_out)
+        const unsigned char **remainder_out, size_t *rlen_out, int recursion)
 {
     asn1_error_code ret;
     unsigned char o;
@@ -431,9 +431,11 @@ get_tag(const unsigned char *asn1, size_
         /* Indefinite form (should not be present in DER, but we accept it). */
         if (tag_out->construction != CONSTRUCTED)
             return ASN1_MISMATCH_INDEF;
+        if (recursion >= 32)
+            return ASN1_OVERFLOW;
         p = asn1;
         while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {
-            ret = get_tag(p, len, &t, &c, &clen, &p, &len);
+            ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);
             if (ret)
                 return ret;
         }
@@ -652,7 +654,7 @@ split_der(asn1buf *buf, unsigned char *c
     const unsigned char *contents, *remainder;
     size_t clen, rlen;
 
-    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);
+    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);
     if (ret)
         return ret;
     if (rlen != 0)
@@ -1259,7 +1261,7 @@ decode_atype(const taginfo *t, const uns
         const unsigned char *rem;
         size_t rlen;
         if (!tag->implicit) {
-            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);
+            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);
             if (ret)
                 return ret;
             /* Note: we don't check rlen (it should be 0). */
@@ -1481,7 +1483,7 @@ decode_sequence(const unsigned char *asn
     for (i = 0; i < seq->n_fields; i++) {
         if (len == 0)
             break;
-        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
+        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);
         if (ret)
             goto error;
         /*
@@ -1539,7 +1541,7 @@ decode_sequence_of(const unsigned char *
     *seq_out = NULL;
     *count_out = 0;
     while (len > 0) {
-        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
+        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);
         if (ret)
             goto error;
         if (!check_atype_tag(elemtype, &t)) {
@@ -1625,7 +1627,7 @@ k5_asn1_full_decode(const krb5_data *cod
 
     *retrep = NULL;
     ret = get_tag((unsigned char *)code->data, code->length, &t, &contents,
-                  &clen, &remainder, &rlen);
+                  &clen, &remainder, &rlen, 0);
     if (ret)
         return ret;
     /* rlen should be 0, but we don't check it (and due to padding in
